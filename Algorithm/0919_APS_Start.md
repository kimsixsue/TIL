[APS_Start](#aps-start)

1. [SW Problem Solving](#1-sw-problem-solving)

2. [Complexity Analysis](#2-complexity-analysis)

3. [STanDard INput OUTput](#3-standard-input-output)

4. [Bitwise Operation](#4-bitwise-operation)

5. [Numeral System](#5-numeral-system)

6. [Real Number](#6-real-number)

# APS_Start

## 1. SW Problem Solving

**SW 문제 해결 역량이란 무엇인가?**

- 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력
- 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있다.
- 문제 해결 역량은 추상적인 기술이다.
  - 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없다.
  - 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않는다.
- 문제 해결 역량을 향상시키기 위해선 훈련이 필요하다.

**문제 해결 능력을 훈련하기 위해서는**

- 일부 새로운 언어, 프레임워크, 개발 방법론만을 배워나가는 것만으로 충분하지 않다. 이들을 조합해 나가는 방법을 배워야 하지만 쉽지 않다.
- 경험을 통해서 나아지리라 막연히 짐작만 한다. 그러나 경험에서는 문제 해결 능력을 개발 할 수 있는 상황이 항상 주어지는 것이 아니며 또한 그런 상황에서 자기 개발을 하기는 쉽지 않다.
- 상황을 인위적으로 만들어 훈련해야 한다. 즉 잘 정제된 추상적인 문제를 제시하고 이를 해결해 가면서 문제 해결 능력을 향상 시킬 수 있는 훈련이 필요하다.

**문제 해결 과정**

1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다.
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

**문제 해결 전략**

- 직관과 체계적인 접근

**체계적인 접근을 위한 질문들**

- 비슷한 문제를 풀어본 적이 있던가?
- 단순한 방법에서 시작할 수 있을까?
- 문제를 단순화 할 수 있을까?
- 그림으로 그려 볼 수 있을까?
- 수식으로 표현 할 수 있을까?
- 문제를 분해 할 수 있을까?
- 뒤에서부터 생각해서 문제를 풀 수 있을까?
- 특정 형태의 답만을 고려할 수 있을까?

## 2. Complexity Analysis

**알고리즘의 효율**

- 공간적 효율성과 시간적 효율성
  - 공간적 효율성은 연산량 대비 얼마나 적은 메모리 공간을 요하는 가를 말한다.
  - 시간적 효율성은 연산량 대비 얼마나 적은 시간을 요하는 가를 말한다.
  - 효율성을 뒤집어 표현하면 Complexity 복잡도가 된다. 복잡도가 높을수록 효율성은 저하된다.

- 시간적 복잡도 분석
  - 하드웨어 환경에 따라 처리시간이 달라진다.
    - 부동소수 처리 프로세서 존재유무, 나눗셈 가속기능 유무
    - 입출력 장비의 성능, 공유여부
  - 소프트웨어 환경에 따라 처리시간이 달라진다.
    - 프로그램 언어의 종류
    - 운영체제, 컴파일러의 종류
  - 이러한 환경적 차이로 인해 분석이 어렵다.

**복잡도의 점근적 표기**

- 시간 (또는 공간)복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러 개의 항을 가지는 다항식이다.
- 이를 단순한 함수로 표현하기 위해 Asymptotic Notation 점근적 표기를 사용한다.
- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.
  - O(Big-Oh) -표기
  - Ω(Big-Omega) -표기
  - Θ(Big-Theta) -표기

**O(Big-Oh)-표기**

- O-표기는 복잡도의 **점근적 상한**을 나타낸다.
- 복잡도가 $f(n) = 2n^2 - 7n + 4$ 이라면, f(n)의 O-표기는 $O(n^2)$이다.
- 먼저 f(n)의 단순화된 표현은 $n^2$이다.
- 단순화된 함수 $n^2$에 임의의 상수 c를 곱한 $cn^2$이 n이 증가함에 따라 f(n)의 상한이 된다.(단, c>0.)
  - 단순히 “**실행시간이 $n^2$에 비례**”하는 알고리즘이라고 말함.

**Ω(Big-Omega)-표기**

- 복잡도의 **점근적 하한**을 의미한다.
- $f(n) = 2n^2 - 7n + 4$의 Ω-표기는 $Ω(n^2)$이다.
- $f(n)=Ω(n^2)$은 “n이 증가함에 따라 $2n^2-7n+4$이 $cn^2$보다 작을 수 없다”라는 의미이다. 이때 상수 c=1로 놓으면 된다.
- O-표기 때와 마찬가지로, Ω-표기도 복잡도 다항식의 최고차항만 계수 없이 취하면 된다.
- “**최소한 이만한 시간은 걸린다**”

**Θ(Theta)-표기**

- O-표기와 Ω-표기가 같은 경우에 사용한다.
- $f(n) = 2n^2 +8n + 3 = O(n^2) = Ω(n^2)$이므로 $f(n)=Θ(n^2)$이다.
- “f(n)은 n이 증가함에 따라 **$n^2$과 동일한 증가율을 가진다**”라는 의미이다.

**자주 사용하는 O-표기**

| O          | 시간                             |
| ---------- | -------------------------------- |
| $O(1)$     | Constant time 상수 시간          |
| $O(logn)$  | Logarithmic time 로그(대수) 시간 |
| $O(n)$     | Linear time 선형 시간            |
| $O(nlogn)$ | Log-linear time 로그 선형 시간   |
| $O(n^2)$   | Quadratic time 제곱 시간         |
| $O(n^3)$   | Cubic time 세제곱 시간           |
| $O(2^n)$   | Exponential time 지수 시간       |

## 3. STanDard INput OUTput

**Python3 표준입출력**

- 입력
  - Raw 값의 입력 : input()
    - 받은 입력값을 문자열로 취급
  - Evaluated된 값 입력 : eval(input())
    - 받은 입력값을 평가된 데이터 형으로 취급
- 출력
  - print()
    - 표준 출력 함수. 출력값의 마지막에 개행 문자 포함
  - print(‘text’, end=‘’)
    - 출력 시 마지막에 개행문자 제외할 시
  - print(‘%d’ % number)
    - Formatting 된 출력

**파일의 내용을 표준 입력으로 읽어오는 방법**

```python
import sys
sys.stdin = open("./input.txt", "r")

text = input()
```

```python
import sys
sys.stdout = open("./output.txt", "w")

print(text)
```

```python
r, c = map(int, input().split())
# 한 줄 입력 받아서 공백 기준으로 나누고, 정수로 형 변환
```

## 4. Bitwise Operation

**비트 연산자**

| 연산자 | 연산자의 기능                                                | 예           |
| ------ | ------------------------------------------------------------ | ------------ |
| &      | 비트단위로 AND 연산을 한다.                                  | num1 & num2  |
| \|     | 비트단위로 OR 연산을 한다.                                   | num1 \| num2 |
| ^      | 비트 단위로 XOR 연산을 한다. (같으면 0 다르면 1)<br />비트 연산자 ^를 두 번 연산하면 처음 값을 반환한다. | num1 ^ num2  |
| ~      | 단항 연산자로서 피연산자의 모든 비트를 반전시킨다.           | num1 ~ num2  |
| <<     | 피연산자의 비트 열을 왼쪽으로 이동시킨다.                    | num1 << num2 |
| >>     | 피연산자의 비트 열을 오른쪽으로 이동시킨다.                  | num1 >> num2 |

**1 << n**

- $2^n$ 의 값을 갖는다.
- 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
- Power set 모든 부분 집합
  - 공집합과 자기 자신을 포함한 모든 부분집합
  - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산된다.

**i & (1 << j)**

- 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미한다.

  ```python
  output += "1" if i & (1 << j) else "0"
  ```

**Endianness 엔디안**

- 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 HW 아키텍처마다 다르다.
- 주의 : 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산 할 때 올바로 이해하지 않으면 오류를 발생 시킬 수 있다.

- 엔디안은 크게 두 가지로 나뉨

  - **Big-endian 빅 엔디안**

    - 보통 큰 단위가 앞에 나옴. 네트워크.

  - **Little-endian 리틀 엔디안**

    - 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터.

      | 종류        | 0x1234의 표현 | 0x12345678의 표현 |
      | ----------- | ------------- | ----------------- |
      | 빅 엔디안   | 12 34         | 12 34 56 78       |
      | 리틀 엔디안 | 34 12         | 78 56 34 12       |

**엔디안 확인 코드**

```python
import sys

print(sys.byteorder)
```

## 5. Numeral System

**2진수, 8진수, 10진수, 16진수**

**10진수 -> 타 진수로 변환**

- 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.

  $$
  (149)_{10} = (10010101)_2 \\
  =(225)_8\\
  =(95)_{16}
  $$

- MSB(most significant bit)

**타 진수 -> 10진수로 변환**

$$
(135)_8 = 1*8^2 +3*8^1+5*8^0=93_{10}
$$

- 소수점이 있을 때

    $$
		(135.12)_8 = 1*8^2 +3*8^1+5*8^0+1*8^{-1}+2*8^{-2}=93.15625_{10}
    $$
    
**2진수, 8진수간 변환**

- 3자리씩 묶음, 나열

**2진수, 16진수간 변환**

- 4자리씩 묶음, 나열

**컴퓨터에서의 음의 정수 표현 방법**

- 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0로 변환한다.

  -6 : 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 : 부호와 절대값 표현.

  -6 : 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 : 1의 보수 표현.

- 2의 보수 : 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다.

  -6 : 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 : 2의 보수 표현.

## 6. Real Number

**실수의 표현**

- **소수점 이하 4자리를 10진수로 나타내보면**

  | 2진수  | 10진수 값 |
  | ------ | --------- |
  | 0.0000 | 0         |
  | 0.0001 | 0.0625    |
  | 0.0010 | 0.125     |
  | 0.0011 | 0.1875    |
  | 0.0100 | 0.25      |
  | 0.0101 | 0.3125    |
  | 0.0110 | 0.375     |
  | 0.0111 | 0.4375    |
  | 0.1000 | 0.5       |
  | 0.1001 | 0.5625    |
  | 0.1010 | 0.625     |
  | 0.1011 | 0.6875    |
  | 0.1100 | 0.75      |
  | 0.1101 | 0.8125    |
  | 0.1110 | 0.875     |
  | 0.1111 | 0.9375    |

**2진 실수를 10진수로 변환하는 방법**

|            | 1001.0011  |        |
| ---------- | ---------- | ------ |
| $1*2^{-4}$ | 1 x 0.0625 | 0.0625 |
| $1*2^{-3}$ | 1 x 0.125  | 0.125  |
| $0*2^{-2}$ | 0 x 0.25   | 0      |
| $0*2^{-1}$ | 0 x 0.5    | 0      |
| $1*2^{0}$  | 1 x 1      | 1      |
| $0*2^{1}$  | 0 x 2      | 0      |
| $0*2^{2}$  | 0 x 4      | 0      |
| $1*2^{3}$  | 1 x 8      | 8      |
|            |            | 9.1875 |

**실수의 표현**

- 컴퓨터는 실수를 표현하기 위해 floating-point 부동 소수점 표기법을 사용한다

- 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식이다.

  - 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현

    $1001.0011 \to 1.0010011 * 2^3$

**실수를 저장하기 위한 형식**

- 단정도 실수(32비트)

  | 부호1비트 | 지수 8비트 | 가수 23비트 |
  | --------- | ---------- | ----------- |

- 배정도 실수(64비트)

  | 부호1비트 | 지수 11비트 | 가수 52비트 |
  | --------- | ----------- | ----------- |

  - mantissa 가수부 : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
  - exponent 지수부 : 실제 소수점의 위치를 지수 승으로 표현한 것

**단정도 실수의 가수 부분을 만드는 방법**

- 예 : 1001.0011

  - 정수부의 첫 번째 자리가 1이 되도록 오른쪽으로 시프트

  - 소수점 이하를 23비트로 만든다

  - 소수점 이하만을 가수 부분에 저장

  - 지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소
  
    $$
    \begin{aligned}
    &0001.0010011 \\
    &0001.00100110000000000000000 \\
    &00100110000000000000000 \\
    &\to 1.0010011 * 2^3
    \end{aligned}
    $$

  

**단정도 실수의 지수 부분을 만드는 방법**

- 지수부에는 8비트가 배정(256개의 상태를 나타낼 수 있음)
- 숫자로는 0-255까지 나타낼 수 있지만, 음수 값을 나타낼 수 있어야 하므로 excess 익세스 표현법을 사용
  - 익세스 표현법 : 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현하는 방법

**단정도 표현에서의 지수부 익세스 표현**

| 실제 지수 | 2진수        | 10진수 값 |
| --------- | ------------ | --------- |
| 128       | 11111111     | 255       |
| 127       | 11111110     | 254       |
| 3         | **10000010** | 130       |
| 2         | 10000001     | 129       |
| 1         | 10000000     | 128       |
| 0         | 01111111     | 127       |
| -1        | 01111110     | 126       |
| -126      | 00000001     | 1         |
| -127      | 00000000     | 0         |

- 예 : 1001.0011 을 단정도 실수로 표현한 예

  | 0    | 10000010 | 00100110000000000000000 |
  | ---- | -------- | ----------------------- |

**컴퓨터는 실수를 근사적으로 표현한다.**

- 이진법으로 표현 할 수 없는 형태의 실수는 정확한 값이 아니라 근사 값으로 저장되는데 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다.

**실수 자료형의 유효 자릿수를 알아 두자.**

- 32 비트 실수형 유효자릿수(십진수) -> 6
- 64 비트 실수형 유효자릿수(십진수) -> 15

**파이썬에서의 실수 표현 범위를 알아보자**

- 파이썬에서는 내부적으로 더 많은 비트를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있다.
- 최대로 표현할 수 있는 값은 약 $1.8 * 10^{308}$ 이고 이 이상은 inf로 표현
- 최소로 표현할 수 있는 값은 약 $5.0 * 10^{-324}$ 이며, 이 이하는 0으로 표현
